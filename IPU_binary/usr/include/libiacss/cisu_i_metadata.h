/*
 * INTEL CONFIDENTIAL
 * Copyright (c) 2017 Intel Corporation. All Rights Reserved.
 *
 * The source code contained or described herein and all documents related to
 * the source code ("Material") are owned by Intel Corporation or its suppliers
 * or licensors. Title to the Material remains with Intel Corporation or its
 * suppliers and licensors. The Material contains trade secrets and proprietary
 * and confidential information of Intel or its suppliers and licensors. The
 * Material is protected by worldwide copyright and trade secret laws and
 * treaty provisions. No part of the Material may be used, copied, reproduced,
 * modified, published, uploaded, posted, transmitted, distributed, or
 * disclosed in any way without Intel's prior express written permission.
 *
 * No license under any patent, copyright, trade secret or other intellectual
 * property right is granted to or conferred upon you by disclosure or delivery
 * of the Materials, either expressly, by implication, inducement, estoppel or
 * otherwise. Any license under such intellectual property rights must be
 * express and approved by Intel in writing.
 */
#ifndef CISU_METADATA_H_
#define CISU_METADATA_H_

#include <cisu_types.h>
#include <vector>
#include <memory>
#include <cstring>
#include <cisu_dll.h>

/**
 * Main enum definitions are in a separate file to make it easy to
 * maintain
 */
#include <cisu_metadata_tags.h>


namespace cisu {

/** \addtogroup cisu_metadata
 *  @{
 */

/**
 * \enum MetadataTypes
 * Enumeration of the base types stored in the metadata buffer.
 */
enum MetadataTypes {
    /** Unsigned 8-bit integer (uint8_t) */
    TYPE_BYTE = 0,
    /** Signed 32-bit integer (int32_t) */
    TYPE_INT32 = 1,
    /** 32-bit float (float) */
    TYPE_FLOAT = 2,
    /** Signed 64-bit integer (int64_t) */
    TYPE_INT64 = 3,
    /**  64-bit float (double) */
    TYPE_DOUBLE = 4,
    /** A 64-bit fraction (MetadataRational) */
    TYPE_RATIONAL = 5,
    /** Number of type fields */
    NUM_TYPES
};

/**
 * \struct MetadataRational
 * Representation of a fraction
 */
struct MetadataRational {
    int32_t numerator;
    int32_t denominator;
};

/**
 * \struct MetadataEntry
 * A reference to a metadata entry in a buffer.
 *
 * The data union pointers point to the real data in the buffer, and can be
 * modified in-place if the count does not need to change. The count is the
 * number of entries in data of the entry's type, not a count of bytes.
 */
struct MetadataEntry {
    /**
     * index of this entry in the buffer
     */
    size_t index;
    /**
     * Unique identification of this entry. The enum of these tags is
     * autogenerated.
     */
    uint32_t tag;
    /**
     * base type of this entry, this is one of the values from enum
     * \ref MetadataTypes
     **/
    uint8_t  type;
    /**
     * Number of items stored in the buffer.
     */
    size_t   count;
    /**
     *
     * This class inside the \ref MetadataEntry struct is used to access the
     * correct item in the data buffer.
     * The correct pointer to use depends on the value of the field type of
     * \ref MetadataEntry.
     */
    union DataPtr {
        uint8_t *u8;
        int32_t *i32;
        float   *f;
        int64_t *i64;
        double  *d;
        MetadataRational *r;
    } data;
};

/**
 * \struct MetadataConstEntry
 * A read-only reference to a metadata entry in a buffer. Identical to
 * \ref MetadataEntry in layout
 */
struct MetadataConstEntry {
    /**
     * index of this entry in the buffer
     */
    size_t   index;
    /**
     * Unique identification of this entry. The enum of these tags is
     * autogenerated.
     */
    uint32_t tag;
    /**
     * base type of this entry, this is one of the values from enum
     * \ref MetadataTypes
     **/
    uint8_t  type;
    /**
     * Number of items stored in the buffer, if 0 it means that the tag was not
     * found
     */
    size_t   count;
    /**
     *
     * This class inside the \ref MetadataConstEntry struct is used to have read
     * only access the correct item in the data buffer.
     * The correct pointer to use depends on the value of the field type
     * of \ref MetadataConstEntry.
     */
    union ConstDataPtr{
        const uint8_t *u8;
        const int32_t *i32;
        const float   *f;
        const int64_t *i64;
        const double  *d;
        const MetadataRational *r;
    } data;
};


/**
 * \class ICisuMetadata
 *
 * This object represents a managed buffer where typed information can be
 * stored, retrieved and sorted. The items stored in this buffer may have an
 * arbitrary size in memory.
 * The memory allocated stores the list of items descriptions (aka entries)
 * as well as the data required to store them.
 */
class ICisuMetadata {
public:
    virtual void destroy() = 0;

    /**
     * Append metadata from another ICisuMetadata object.
     */
    virtual CisuError appendMeta(const ICisuMetadata &other) = 0;

    /**
     * Return the amount of metadata entries currently stored in the buffer.
     */
    virtual size_t entryCount() const = 0;

    /**
     * returns true if the buffer does not contain any entries
     */
    virtual bool empty() const = 0;

    /**
     * returns capacities for entries and data
     */
    virtual void capacity(size_t &entryCapacity, size_t &dataCapacity) const = 0;

    /**
     * Sort the entries in the metadata buffer to make the find operation
     * quicker.
     */
    virtual CisuError sort() = 0;

    /**
     * Metadata update methods.
     * Methods used to update metadata entries by tag. Same method overloaded to
     * support all the valid basic types plus array of those types.
     *
     * It will create entry if it doesn't exist already.
     * It will reallocate the buffer if insufficient space exists.
     */
    virtual CisuError updateTag(uint32_t tagId, const float *dataPtr, size_t itemCount) = 0;
    virtual CisuError updateTag(uint32_t tagId, const int32_t *dataPtr, size_t itemCount) = 0;
    virtual CisuError updateTag(uint32_t tagId, const uint8_t *dataPtr, size_t itemCount) = 0;

    template<typename T>
    CisuError updateTag(uint32_t tagId, std::vector<T> data) {
        return update(tagId, data.array(), data.size());
    }

    /**
     * Retrieve a metadata entry by tag id.
     * If the tag is not found the metadata entry will be empty, i.e. the item
     * count will be 0.
     */
    virtual MetadataEntry find(uint32_t tagId) = 0;

    /**
     * Retrieve a metadata entry by tag id.
     * The return object does not allow modifications of the stored information.
     * If the tag is not found the metadata entry will be empty, i.e. the item
     * count will be 0.
     */
    virtual MetadataConstEntry find(uint32_t tagId) const = 0;

    /**
     * Remove all content from  metadata but keeps capacity
     */
    virtual CisuError flush() = 0;
};

extern "C" CISU_EXPORT_TO_DLL CisuError CISU_DLL_API CisuMetadataAllocator(size_t capacity, std::vector<ICisuMetadata*> &pointers);
extern "C" CISU_EXPORT_TO_DLL ICisuMetadata* CISU_DLL_API GetCisuMetadata(size_t entryCount, size_t dataSize);

}

/**
 *  @}
 */
#endif /* CISU_METADATA_H_ */
